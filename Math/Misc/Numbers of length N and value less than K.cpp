// Bucket - Array dp

// Given a set of digits (A) in sorted order, find how many numbers of length B are possible whose value is less than number C.
// NOTE: All numbers can only have digits from the given set, number can be repeated any number of times 

// Input:
//     0 1 2 5  
//     2  
//     21  
// Output:
//     5 (10, 11, 12, 15, 20 are possible)

// Approach: 1D DP

// Let us try to solve for all the possible cases.
// Let d be size of A.

// Case 1: If B is greater than length of C or d is 0 then no such number is possible.

// Case 2: If B is smaller than length of C then all the possible combination of digits of length B are valid.

// Generate all such B digit numbers.
// For the first position we can’t have 0 and for ther rest of (B - 1) position we can have all d possible digits.
// Hence, Answer = d ^ B if A contains 0 else (d-1) * ( d ^ (B-1) )

// Case 3: If B is equal to length of C
// Construct digit array of C ( call it as digit[]).

// Let First(i) be a number formed by taking first i digits of it.
// Let lower[i] denote number of elements in A which are smaller than i.
// It can be easily computed by idea similar to prefix sum.

// For example:

// First(2) of 423 is 42. 
// If  A =  [ 0, 2] then lower[0] = 0, lower[0] = 0, lower[1]  = 1,  lower[2] = 1, lower[3] = 2  
// Generate B digit numbers by dynamic programming. Let say dp[i] denotes the total numbers of length i which are less than first i digits of C.

// Elements in dp[i] can be generated by two cases :

// i) For all the Numbers whose First(i - 1) is less than First (i-1) of C, we can put any digit at i’th index.
// Hence, dp[i] += (dp[i-1] * d)

// ii) If First (i - 1) is same as First (i - 1) of C, we can also put those digits which are smaller than digit[i] .
// Hence , dp[i] += lower[digit[i]]

// Final answer will be dp[B]

// Remark:
// For first index don’t include 0 if B is not 1 and dp[0] will be 0.

// Time Complexity = O(B)



vector<int> numToVec(int N) {   
    vector<int> digits;
    while(N>0) {
        digits.push_back(N % 10);
        N=N/10;
    }
    if(digits.size()==0) digits.push_back(0);
    reverse(digits.begin(), digits.end());
    return digits; 
}

int Solution:: solve(vector<int> &A, int B, int C) {
    vector<int> digits = numToVec(C); // Convert number to digits array
    int n=A.size();

    //Case 1
    if(B>digits.size()||n==0) return 0;

    // Case 2
    else if(B<digits.size()){
        if(A[0]==0&&B!=1) return (n-1)*pow(n,B-1); // contains 0
        else return pow(n,B);
    }

    //Case 3
    else {
        int dp[B+1]={0}; // denotes the total numbers of length i which are less than first i digits of C
        int lower[11]={0};
        
        for(int i=0;i<n;i++) lower[A[i]+1] = 1;
        
        for(int i=1;i<=10;i++) lower[i] = lower[i-1] + lower[i]; 
        
        bool flag = true;
        dp[0]=0;
        for(int i = 1; i <= B; i++) {
            dp[i] = dp[i-1]*n;

            int lastDigit = digits[i-1];

            //Whether (i-1) digit of generated number can be equal to (i - 1) digit of C.
            if(flag){
                bool cantUseZero = (i==1&&A[0]==0&&B!=1); // For first index we can't use 0
                dp[i] += lower[lastDigit]-cantUseZero;  
            } 
            
            //Is digit[i - 1] present in A ?
            flag = flag & (lower[lastDigit+1] == lower[lastDigit]+1);
        }
        return dp[B];                   
    } 
}
